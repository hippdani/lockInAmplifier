//Pin 9 has to be the Reference frequency signal OUTPUT on Arduino UNO. only 4MHz available.
//#include "pico/stdlib.h"
//#include <Arduino.h>
//#include <CoreMutex.h>
//#include <hardware/gpio.h>
//#include <hardware/clocks.h>
//#include <hardware/pll.h>
//#include <hardware/adc.h>
#ifndef __AVR_ATmega328P__
  #include <hardware/pwm.h> //only needed for PiPico
#endif



long Reference_freq = 4000000;  //Reference frequency for the DDS, generated by ÂµC or externally

void dds_init()
{
  #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__)
    Reference_freq = dds_init_clock_ref_arduino(Reference_freq);
  #else
    Reference_freq = dds_init_clock_ref_pico(Reference_freq);
    SPI.setRX(MISO0); //MISO?
    SPI.setTX(MOSI0); //MOSI?
    SPI.setSCK(SPICLK0);//SPI Clock
  #endif
  //Setting the SPI pins only valid for PiPico
  
  //setCS(21); //Ignored, because it is set in software
  SPI.begin(); //No Argument, because SPI defaults to software CS
  pinMode(DDS_FSYNC_PIN, OUTPUT);
  
}

//UNO: activate Timer as 4MHz clock
//pico: do something to get >=4 MHz signal
long dds_init_clock_ref_arduino(long ref_freq)
{
 /* pinMode (9, OUTPUT); 
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
  OCR1A = 1;   // toggle after counting to 8
  TCCR1A |= (1 << COM1A0);   // Toggle OC1A on Compare Match.
  TCCR1B |= (1 << WGM12);    // CTC mode
  TCCR1B |= (1 << CS10);     // clock on, no pre-scaler*/
  return(4000000); //Always returns 4000000, because the code for the registers gives this fixed value, which is also the maximum (Clock/4)
}

long dds_init_clock_ref_pico(long ref_freq)
{
  return((long)high_freq_PWM(CLOCK_REF_PIN_PICO, ref_freq, 128)); //Returns the actually genereted freq, because not every value is possible by dividing the Master clock.
}

void dds_set_freq(long freq)
{
  unsigned long freqreg = (unsigned long)(freq  / (double)Reference_freq * pow(2,28));
  unsigned long highMsg = 0b0100000000000000 | (int)((freqreg >> 14) & 0b0011111111111111);
  byte highMsgArr[] = {(byte)(highMsg >> 8),(byte)(highMsg&0xFF)};
  unsigned long lowMsg = 0b0100000000000000 | (int)((freqreg & 0b0011111111111111));
  byte lowMsgArr[] = {(byte)(lowMsg >> 8),(byte)(lowMsg&0xFF)};

  byte FREQ0_selectArr [] = {0b00100000, 0b00000000};
  SPI.beginTransaction(SPISettings(900000, MSBFIRST, SPI_MODE2)); //old speed 2500
  delayMicroseconds(105);
  digitalWrite(DDS_FSYNC_PIN, LOW);
  SPI.transfer(FREQ0_selectArr,2);
  digitalWrite(DDS_FSYNC_PIN, HIGH);
  delayMicroseconds(5);
  
  digitalWrite(DDS_FSYNC_PIN, LOW);
  SPI.transfer(lowMsgArr,2);
  digitalWrite(DDS_FSYNC_PIN, HIGH);
  delayMicroseconds(5);
  
  digitalWrite(DDS_FSYNC_PIN, LOW);
  SPI.transfer(highMsgArr,2);
  digitalWrite(DDS_FSYNC_PIN, HIGH);
  SPI.endTransaction();
    
}

float high_freq_PWM(int pin, long frequency, byte duty)  //2029 Hz is minimum, Output wont go lower. requires #include <hardware/pwm.h>
{
  unsigned int top = clock_get_hz(clk_sys)/frequency - 1; //PWM register counts up to top+1 before wrapping to 0 (and toggling output)
  if(top >= 0xFFFF) top = 0xFFFE;  //With the divider fixed to one small frequencys cannot be achieved. Use normal analogWrite instead.
  unsigned int counterCompare = top * duty / 255; //+1? Value of counter at which the output is toggled (back)
  pwm_config c = pwm_get_default_config();
  pwm_config_set_clkdiv(&c, 1);
  pwm_config_set_wrap(&c, top);
  pwm_init(pwm_gpio_to_slice_num(pin), &c, true);
  gpio_set_function(pin, GPIO_FUNC_PWM);
  pwm_set_gpio_level(pin, counterCompare);
  return (clock_get_hz(clk_sys)/(top+1));
}

void loadQTFfreq()
{
  //get QTF resonance or drive freq from EEPROM / Flash and store into (global) variable
}
